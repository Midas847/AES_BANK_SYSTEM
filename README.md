

***Encryption Algorithms Currently Used By Banking***

***Institutions And How To Improve Them Using 256-***

***Bit Encryption?***

Rehber Bin Moin Saswata Ghosh

**20BKT0126 20BKT0100**

+91-877 727 4697 +91-731 973 3386

<rehberbin.moin2020@vitstudent.ac.in>[ ](mailto:rehberbin.moin2020@vitstudent.ac.in)<saswata.ghosh2020@vitsudent.ac.in>

**Guided By:** Dr. Bhulakshmi B.

**Designation:** Assistant Professor (Senior)

**Phone Number:** +91-979 086 2137

**Email: <bhulakshmi.b@vit.ac.in>**

**B. Tech.**

In

**Computer Science and Engineering**

**School of Computer Science and Engineering (SCOPE)**

December, 2021





**Table of Contents**

[**1.**](#br4)[** ](#br4)[ABSTRACT**](#br4)

[**1**](#br4)

[**1**](#br4)

[**2.**](#br4)[** ](#br4)[INTRODUCTION**](#br4)

[**2.1.**](#br4)[** ](#br4)[T**](#br4)[HEORETICAL**](#br4)[** ](#br4)[B**](#br4)[ACKGROUND**](#br4)

[**2.2.**](#br5)[** ](#br5)[M**](#br5)[OTIVATION**](#br5)

[**1**](#br4)

[**2**](#br5)

[**3**](#br6)

[**3**](#br6)

[**2.3.**](#br6)[** ](#br6)[A**](#br6)[IM**](#br6)[** ](#br6)[OF**](#br6)[** ](#br6)[THE**](#br6)[** ](#br6)[P**](#br6)[ROPOSED**](#br6)[** ](#br6)[W**](#br6)[ORK**](#br6)

[**2.4.**](#br6)[** ](#br6)[O**](#br6)[BJECTIVE**](#br6)[(**](#br6)[S**](#br6)[)**](#br6)[** ](#br6)[OF**](#br6)[** ](#br6)[THE**](#br6)[** ](#br6)[P**](#br6)[ROPOSED**](#br6)[** ](#br6)[W**](#br6)[ORK**](#br6)

[**3.**](#br7)[** ](#br7)[LITERATURE**](#br7)[** ](#br7)[SURVEY**](#br7)

[**4**](#br7)

[**3.1.**](#br7)[** ](#br7)[S**](#br7)[URVEY**](#br7)[** ](#br7)[OF**](#br7)[** ](#br7)[E**](#br7)[XISTING**](#br7)[** ](#br7)[M**](#br7)[ODELS**](#br7)[** ](#br7)[/**](#br7)[** ](#br7)[W**](#br7)[ORK**](#br7)

[**3.2.**](#br9)[** ](#br9)[S**](#br9)[UMMARY**](#br9)[** ](#br9)[/**](#br9)[** ](#br9)[G**](#br9)[APS**](#br9)[** ](#br9)[I**](#br9)[DENTIFIED**](#br9)

[**4**](#br7)

[**6**](#br9)

[**4.**](#br9)[** ](#br9)[OVERVIEW**](#br9)[** ](#br9)[OF**](#br9)[** ](#br9)[PROPOSED**](#br9)[** ](#br9)[SYSTEM**](#br9)

[**6**](#br9)

[**4.1.**](#br9)[** ](#br9)[I**](#br9)[NTRODUCTION**](#br9)

[**6**](#br9)

[**7**](#br10)

[**8**](#br11)

[**4.2.F**](#br10)[RAMEWORK**](#br10)[** ](#br10)[AND**](#br10)[** ](#br10)[A**](#br10)[RCHITECTURE**](#br10)

[**4.3.**](#br11)[** ](#br11)[P**](#br11)[ROPOSED**](#br11)[** ](#br11)[S**](#br11)[YSTEM**](#br11)[** ](#br11)[M**](#br11)[ODEL**](#br11)

[**5.**](#br13)[** ](#br13)[PROPOSED**](#br13)[** ](#br13)[SYSTEM**](#br13)[** ](#br13)[DESIGN**](#br13)[** ](#br13)[AND**](#br13)[** ](#br13)[ANALYSIS**](#br13)

[**10**](#br13)

[**5.1.**](#br13)[** ](#br13)[I**](#br13)[NTRODUCTION**](#br13)

[**10**](#br13)

[**10**](#br13)

[10](#br13)

[10](#br13)

[10](#br13)

[11](#br14)

[11](#br14)

[11](#br14)

[12](#br15)

[12](#br15)

[12](#br15)

[13](#br16)

[**5.2.**](#br13)[** ](#br13)[R**](#br13)[EQUIREMENT**](#br13)[** ](#br13)[A**](#br13)[NALYSIS**](#br13)

[5.2.1.](#br13)[ ](#br13)[F](#br13)[UNCTIONAL](#br13)[ ](#br13)[R](#br13)[EQUIREMENTS](#br13)

[5.2.1.1.](#br13)[ ](#br13)[Product](#br13)[ ](#br13)[Perspective](#br13)

[5.2.1.2.](#br13)[ ](#br13)[Product](#br13)[ ](#br13)[Features](#br13)

[5.2.1.3.](#br14)[ ](#br14)[User](#br14)[ ](#br14)[Characteristics](#br14)

[5.2.1.4.](#br14)[ ](#br14)[Assumptions](#br14)[ ](#br14)[&](#br14)[ ](#br14)[Dependencies](#br14)

[5.2.1.5.](#br14)[ ](#br14)[Domain](#br14)[ ](#br14)[Requirements](#br14)

[5.2.1.6.](#br15)[ ](#br15)[User](#br15)[ ](#br15)[Requirements](#br15)

[5.2.2.](#br15)[ ](#br15)[N](#br15)[ON](#br15)[-F](#br15)[UNCTIONAL](#br15)[ ](#br15)[R](#br15)[EQUIREMENTS](#br15)

[5.2.2.1.](#br15)[ ](#br15)[Product](#br15)[ ](#br15)[Requirements](#br15)

[5.2.2.2.](#br16)[ ](#br16)[Organizational](#br16)[ ](#br16)[Requirements](#br16)

i





[5.2.2.3.](#br16)[ ](#br16)[Operational](#br16)[ ](#br16)[Requirements](#br16)

[5.2.3.](#br17)[ ](#br17)[S](#br17)[YSTEM](#br17)[ ](#br17)[R](#br17)[EQUIREMENTS](#br17)

[5.2.3.1.](#br17)[ ](#br17)[Hardware](#br17)[ ](#br17)[Requirements](#br17)

[5.2.3.1.](#br17)[ ](#br17)[Software](#br17)[ ](#br17)[Requirements](#br17)

[13](#br16)

[14](#br17)

[14](#br17)

[14](#br17)

[**6.**](#br18)[** ](#br18)[RESULTS**](#br18)[** ](#br18)[AND**](#br18)[** ](#br18)[DISCUSSIONS**](#br18)

[**15**](#br18)

[**6.1.**](#br18)[** ](#br18)[C**](#br18)[ODE**](#br18)[** ](#br18)[R**](#br18)[EVIEW**](#br18)

[**15**](#br18)

[**17**](#br20)

[**19**](#br22)

[19](#br22)

[19](#br22)

[**6.2.**](#br20)[** ](#br20)[S**](#br20)[CREENSHOTS**](#br20)[** ](#br20)[OF**](#br20)[** ](#br20)[THE**](#br20)[** ](#br20)[P**](#br20)[RODUCT**](#br20)

[**6.3.**](#br22)[** ](#br22)[E**](#br22)[NDING**](#br22)[** ](#br22)[R**](#br22)[EMARKS**](#br22)[** ](#br22)[AND**](#br22)[** ](#br22)[C**](#br22)[ONCLUSIONS**](#br22)

[6.3.1.](#br22)[ ](#br22)[R](#br22)[ESEARCH](#br22)[ ](#br22)[&](#br22)[ ](#br22)[D](#br22)[EVELOPMENT](#br22)[ ](#br22)[C](#br22)[ONCLUSIONS](#br22)

[6.3.2.](#br22)[ ](#br22)[I](#br22)[NDUSTRY](#br22)[ ](#br22)[D](#br22)[ISCUSSIONS](#br22)

[**7.**](#br24)[** ](#br24)[REFERENCES**](#br24)

[**21**](#br24)

[This Space Has Been Intentionally Kept Blank. Kindly Omit.]

ii





\1. Abstract

Since we are moving towards a future where almost everything will be based online; therefore,

it is to the best of our interests that we make the internet a more secure place. The frontier of

web-based security comes from Encryption and Data Hiding. It is in our best interest to migrate

to a more substantial encryption standard that will stand the test of time. Currently, we are

using RSA and AES 128-bit for our Encryption needs. Although pretty robust, with the current

trends in computing power and the leaps that we are making in quantum computing, it is a very

likely possibility that these encryption standards will be rendered obsolete.

Our current systems are vulnerable to a smörgasbord of different attack and strong-arming

techniques, including but not limited to Sieve MiTM Attack, Biclique Analytical Attacks, and

others. As mentioned above, they are pretty robust, but they are at the mercy of time. When the

QCs take over from Silicone Based Architecture, it will be a matter of minutes to exhaust all

possible keys. Therefore AES 256-bit encryption will help us mitigate most of these issues.

***Keywords*** − *Advanced Encryption Standard (AES), Biclique Attacks, Quantum Computing.*

\2. Introduction

2.1. Theoretical Background

***“Your data is not safe!”*** – Edward Snowden, the whistle-blower behind the NSA surveillance

revelations. It is a fact. The internet is growing faster than ever, estimated to be growing at a

rate of over 3,000%. The internet has changed how we live our lives in the last decade. Now,

we have a question that we must ask ourselves.

***“Is the current protection we get, in the form of encryption, is enough to mitigate/prevent***

***future attacks?”.***

The answer to this question, unfortunately, is **No**. In this project, we will show that the current

security standards are very close to being broken, and there are no contingencies in place to

prevent the fallout in the event of a catastrophic failure.

1





2.2. Motivation

The Other Theoretical Attacks On AES-128 Which Is Based On The Biclique Cryptanalysis

**2011:** Biclique Cryptanalysis of the Full AES, Bogdanov et al.

**2012:** Better than Brute-Force - Optimized Hardware Architecture for Efficient Biclique

Attacks on AES-128, Bogdanov et al.

**2013:** Sieve-in-the-Middle: Improved MITM Attacks, Canteaut et al.

**2014:** A Framework for Automated Independent-Biclique Cryptanalysis, Abed et al.

**2015:** Bicliques with Minimal Data and Time Complexity for AES, Bogdanov et al.

**2016:** Improving the Biclique Cryptanalysis of AES, Tao et al.

**Data**

**w/o**

**Mem. Bytes With SIM Mem. Bytes**

**Reference**

**SIM**

88

126.21

14.32

14.32

\-

\-

\-

Bogdanov et al. 2011

Bogdanov et al. 2012

Canteaut et al. 2013

Abed et al. 2014

Bogdanov et al. 2015

\-

2

2

2

2

4

126.89

\-

2

2

\-

\-

\-

126.01

64

2

2

72

126.72

14.32

\-

\-

2

2

2

2

2

2

2

2

2

2

2

2

126.67

126.16

126.13

126.01

14.32

14.32

22.07

64.14

126.59

64

2

2

2

2

2

2

2

2

64

126.01

125.99

125.87

64

64

64

2

2

2

56

72

Tao et al. 2016

Tao et al. 2016

*Figure 1: Best MiTM Attack on 6 Rounds*

In short, theoretically, one can say it gets broken since the attack requires less computation

than brute force. However, the attack time and data complexity are not practical, either. From

2





the paper; As our attacks are of high computational complexity, they do not threaten the

practical use of AES in any way. However, with the increasing advancements in Quantum

Computing and Better Silicon Technologies, our current 128-bit AES will not be able to

stand the test of time for much longer.

2.3. Aim of the Proposed Work

According to leaked documents by Edward Snowden, NSA looking for tau statics to break

AES is on a side note. After this revelation, consistent and robust encryption is a requirement

from governments. After five years, nothing related to tau statics, and AES appeared in the

academics area.

Therefore, to mitigate the attacks that exist now or in the possible future, we need to double

the key size. In AES, this makes AES-256. If we consider the overhead of using the AES

with a 256-bit key, in which we need 14 rounds, in CPU, this makes around 40% percentage

overhead. So, as stated in comments by Prof. Lindell, in marketing AES-256, sounds better

and becomes the standard.

The 256-bit marketing also may come from the US/NATO military regulations which use

several distinct security levels (e.g. confidential = 128, secret = 192, top-secret =256). The 17

years old document from June 2003 states top-secret must be 192 or 256 bits keys.

***"Thus, AES-128 will have 64, and AES-256 will have 128-bit security if someone can***

***build a QC (Quantum Computer). If we consider our assets valuable, the reasonable choice***

***is to double the key size."***

2.4. Objective(s) of the Proposed Work

Banks and other institutions' most widely used encryption technique is 128-bit AES (Advanced

Encryption Standard) or an even older RSA. Although it is pretty fast and robust, there are still

ways in which this can fall apart. The key of AES-128 can get recovered with a computational

complexity of 2126.1 shown in Biclique Cryptanalysis of the Full AES by Bogdanov et al., using

the biclique attack achieved in 2016. Therefore, we must change the standard of encryption to

prevent future attacks on our data.

3





\3. Literature Survey

3.1. Survey of Existing Models / Work

**Biclique Cryptanalysis of the Full AES**

*By Bogdanov A., Khovratovich D., Rechberger C. (2011)*

**Proposed Idea:**

In this paper, the authors elaborate on the fact that Rijndael was chosen as the Advanced

Encryption Standard (AES), improving upon 7-round attacks on the 128-bit key variant (out of

10 rounds) or upon 8-round attacks on the 192/256-bit key variants (out of 12/14 rounds) has

been one of the most difficult challenges in the cryptanalysis of block ciphers for more than a

decade.

**Key Takeaways:**

We learnt about the eventual shortcomings of the conventional encryptions that we use on a

day-to-day basis, and how they have vulnerabilities that can render its security useless.

**Multiple Differential Cryptanalysis of Round-Reduced PRINCE**

*By Canteaut A., Fuhr T., Gilbert H., Naya-Plasencia M., Reinhard JR. (2015)*

**Proposed Idea:**

In this paper the authors discuss the idea behind PRINCE, a lightweight block cipher proposed

by Borghoff et al. at ASIACRYPT 2012. PRINCE is defined as a member of a family of

ciphers, differing by the choice of an *Substitution Box (S-Box)* among a distinguished set. They

also showed that the security offered by all the members of the family is not equivalent, by

identifying an *S-Box* for which the attack can be extended up to 11 rounds with a data

complexity of 259.81 and a time complexity of 262.43.

**Key Takeaways:**

These new ciphers are being able to provide substantial encryption but they still can be strong-

armed into being broken.

4





**A Framework for Automated Independent-Biclique Cryptanalysis**

*By Abed F., Forler C., List E., Lucks S., Wenzel J. (2014)*

**Proposed Idea:**

In this paper the authors introduce Janus, a software framework – written in Java – which is

built to provide assistance in finding independent-biclique attacks for a user-chosen set of

parameters. Janus not only finds an optimal bipartite graph (biclique), but also provides an all-

round carefree package of finding an optimal matching-with-precomputation step, rendering

the found biclique, and determining the computational complexity of the attack.

**Key Takeaways:**

The Janus framework is used to verify existing results on ARIA and the AES. Additionally, by

using this framework, we could find the first full-round biclique attacks on all versions of the

AES-like cipher BKSQ. This in turn shows the vulnerability of AES and other encryption

standards.

**Improving the Biclique Cryptanalysis of AES**

*By Tao, Biaoshuai and Hongjun Wu. “Improving the Biclique Cryptanalysis of*

*AES.” ACISP (2015).*

**Proposed Idea:**

Biclique attack is currently the only key-recovery attack on the full AES with a single key.

Bogdanov et al. applied it to all the three versions of AES by constructing bicliques with size

28 times 28 and reducing the number of *S-Boxes* computed in the matching phase.

**Key Takeaways:**

Their results were improved later by better selections of differential characteristics in the

biclique construction. In this paper, we improve the biclique attack by increasing the biclique

size to 216 times 28 and 216 times 216. We successfully get a biclique attack on each of the AES

versions.

[This Space Has Been Intentionally Kept Blank. Kindly Omit.]

5





3.2. Summary / Gaps Identified

Our research found a considerable promise that Quantum Computing is poised to render current

cryptography techniques obsolete. There is near scientific consensus that quantum computers

will break widely used public-key cryptographic schemes such as RSA, Diffie-Hellman and

AES. Furthermore, the transition to new quantum-resistant cryptographic algorithms will take

years.

Thankfully we have a head start. Not only are researchers developing new, quantum-resistant

encryption methodologies, some already exist. Lattice-based, code-based, hash-based,

isogeny-based, and multivariate systems are all examples of quantum-resistant PKC systems.

Until we can develop reliable Quantum Based Crypto Agile Solutions, we must increase the

currently used key size to hold off any future attacks.

Another Solution may be Homomorphic Encryption. Though conceptualized in 1978,

homomorphic encryption is just now shifting into a reality. A technique that allows for

computations to get executed on encrypted data without having to use a key, homomorphic

encryption enables data owners or a third party to implement functions on encrypted data

without necessitating revealing the values of the data.

The results are also encrypted and require a key to access. When combined with blockchain,

homomorphic encryption could usher in a new era of agile, highly resilient cybersecurity and

encryption strategies. Currently this is more CPU intensive compared to simply increasing our

key size. So it cannot be feasibly used for banking transactions.

\4. Overview of Proposed System

4.1. Introduction

AES encryption makes use of a hardware-based set of protection modules and an AES engine.

When the host writes data, then a Random Number Generator (RNG) produces the 256-bit

symmetric cypher key, which gets transferred to the AES engine. Next, the AES engine

encrypts the plain text into cypher text. Conversely, if the host wants to recover data from its

encrypted state, the AES engine decrypts the cypher text and transfers it to the host as plain

text. Here is how our implementation works.

6





There is a flowchart that shows how the requests get processed and we end up with the ability

to encrypt our data. This makes sure that whenever we send a transaction request, it is secured

with the AES Encryption standard which has parts of Diffie-Hellman incorporated into it.

*Figure 2: Algorithmic Flowchart*

4.2.Framework and Architecture

First, the user sends their log-in details through a front-end form, which is written in React. It

uses Express Server to relay the details given by the user to the backend. Here the majority of

the encryption/decryption gets done. Our Node.js backend makes a POST Request to our

Database after it has encrypted our password.

*Figure 3: Execution Block-Diagram*

7





Whenever the user wants to fetch their password, the server makes a GET Request to our

Database. It receives the encrypted password along with the required shared key and

authentication tag. After getting decrypted, it gets sent back to the user, and the process is

complete.

*Figure 4: Request Flow*

4.3. Proposed System Model

*Figure 5: The Proposed Entity-Relationship Model (Simplified)*

8





This is the E-R model of our hypothesized system. Due to the scope of this project, the current

model doesn’t scale up well. There can be many more Entities and Relationships that might

extend the real-life deployability of our project. But, for now it functions merely as a proof of

concept and functions as intended.

We may include provisions for things like:

• Frequently Paid Users and Services

• Cashback Rewards based on Transaction Amount

• Integration with existing services

• Gamification to improve the service’s DAU (Daily Active Users)

*Figure 6: The Proposed UML Diagram (Simplified)*

Again, this is a gross oversimplification of the total number of elements that can be included

in the UML diagram. Due to the scope of this project we have overlooked many potential

elements that might be added in when scaling this project up.

9





\5. Proposed System Design and Analysis

5.1. Introduction

As discussed in the previous section, our Proposed System is very rudimentary and in-

extensive. So, in this section, we shall be going through the Requirements to deploy such a

product. Our requirements will solely be restricted to that of a small-scale, locally deployed

solution. A full run-down of this project when scaled up is beyond the scope of this project.

5.2. Requirement Analysis

5.2.1. Functional Requirements

5.2.1.1. Product Perspective

We need to remember that this project is limited to serving only as a proof of concept. We will

not use it for anything more than for demonstration purposes only. Our product is just a

barebones banking website where we show that the transactions are processed using AES 256-

bit Encryption methods.

It allows users to deposit and transact amounts ranging from ₹1 to ₹70,000. Approximately a

limit till $1,000. It is a relatively tame amount, and users will be able to safely transact using a

user-specified transaction code that the user must input first to complete the transaction.

5.2.1.2. Product Features

We have fundamental provisions to protect our data from XSS and SQL Injection attacks. To

illustrate this, let us take a simple example of an online transaction. When one carries out a

transaction on a website, it runs some JavaScript to take one’s credentials from these input

fields and process them. However, the hackers can quickly run some added JavaScript to do

something damaging with that information.

We have managed to implement measures against SQL injection attacks and XSS. We have

used React DOM, which escapes any values embedded in JSX before administering them. Thus

it ensures that one can never inject anything that’s not explicitly written in our application.

Everything gets converted to a string before being rendered. It helps prevent XSS attacks.

Additionally, we have implemented a rudimentary Session Management System.

10





5.2.1.3. User Characteristics

The user will have the ability to register themselves from the website if they do not have an

account beforehand. After creating an account, a user can sign in and add data like their

Address, PAN Card Number and other details. This step ensures that any sensitive information

does not leak out when initially signing up for the website.

The user will also get the ability to Deposit and Withdraw amounts from their Linked Bank

Accounts. Each of the fields gets tested to be XSS and SQL Injection Compliant. Proper

validations for the amounts get done in this section, followed by Encrypting the actual

Transaction. Below, we show the information that we store of the user.

*Figure 7: Example of our sample user Database.*

5.2.1.4. Assumptions & Dependencies

Since the website is currently locally hosted, it requires many prerequisites to function

correctly. We shall go over the exact Hardware and Software Dependencies in the later

sections; we must establish the fact that with some capital, this website can get hosted using

services like Heroku or Netlify. They will allow us to connect to a DB of our choice.

Since this is just a simple, proof-of-concept type project, we have not hosted it on the actual

net. However, the provisions are there for us to do it.

5.2.1.5. Domain Requirements

Since this is primarily a Banking Domain type website, information like IFSC Code, Bank

Account Number, Address, Phone Number, etc., are essential domain requirements.

11





5.2.1.6. User Requirements

Program Requirements:

The user must be able to create an account and log in. The user must also get the ability to

change their personal information like Address, Phone Number, etc. Also, the user must be

able to conduct two types of transactions. Withdrawals and Deposits.

Data Requirements:

The system must be able to process basic arithmetic to check for the possibility of transactions.

It should also be capable of generating encrypted IVs and deciphering them after checking its

Authentication Tags.

5.2.2. Non-Functional Requirements

5.2.2.1. Product Requirements

The most important characteristic that the product must fulfil is the ability for the user to safely

transact through the means of the 256-bit AES encryption standard. The secondary requirement

is to provide the user with an experience that they will enjoy. Making it intuitive and elegant

is the tertiary product requirement.

5.2.2.1.1. Efficiency: The website must be capable of generating a Random ECDH Curve for

generating our cipher initialization vector. Since ours is locally hosted, it is entirely reliant on

the system specifications. There is no bottleneck for our storage as any modern device will

support reading and writing data for our encryption and storage needs.

5.2.2.1.2. Reliability: The exact way we generate our encryption keys and functions is pretty

reliable as it mostly depends on the Perlin Noise that our machines naturally make. This allows

us to generate pseudorandom numbers rather effectively.

5.2.2.1.3. Portability: Since this is merely a web client, it can be used on any device with

adequate hardware and software support. In our case, it is locally hosted, but upon publishing

it, we need not worry about it.

12





5.2.2.1.4. Usability: The UI is relatively intuitive, and everything is legible and easy to

interpret. Although, when scaling it up, we must ensure screen-reader compatibility.

5.2.2.2. Organizational Requirements

5.2.2.2.1. Implementation Requirements: For a relatively small userbase, we may consider

cheap and reliable services like AWS, Netlify, Heroku, etc., to name a few. The backend can

be managed by using a Custom Solution or using an easy to deploy solution like Digital Ocean.

Since this is merely a proof-of-concept, any machine with the basic specifications can host a

website like this.

5.2.2.2.2. Engineering Standard Requirements: The system must be available 24x7 without any

downtime. It should be capable of handling multiple user requests simultaneously. The

database should be fast enough to make everything easier for the processing of data.

Adequate processing power must be present to crunch through the computations required to

encipher and decipher outgoing and incoming data, respectively. Concurrency support should

be present. In the case of power outages, contingencies must be present to divert traffic from

the offline server to other working clients. Although we can add more fail-safes, these are

adequate for the scope of our project.

5.2.2.3. Operational Requirements

Since this is a website built mostly for transactions, it will be perfect for applications in the

Economic domain. It would allow users to freely transact small amounts safely and securely,

preventing them from falling victim to common scams like MiTM Attacks, Email Phishing,

etc., as our USP is the usage of a Transaction Code that gets encrypted with the user data.

Also, with the help of implementing 2FA (Two-Factor Authentication) in the future versions

of the website, it will become almost impermeable to a range of web-based attacks.

Incorporating the usage of Biometric authentication with the usage of FaceIDᵀᴹ, TouchIDᵀᴹ,

etc., will make it more difficult for our product to fail. Therefore it has great potential in the

Payments, Finance and Economic domains.

13





5.2.3. System Requirements

The website was run on two different machines across two different platforms and operating

systems to see whether there was any discernible difference in performance. We could not find

any. The website will run on any device with an up-to-date hardware and software. Here are

the specification of our local machine on which we hosted our website.

We can refer to the minimum hardware requirements for the listed software and get a basic

idea about the absolute bare minimum necessity for our website. To give a ballpark estimate,

the following is the bare minimum hardware requirement to run the website locally.

2 GB of RAM (8 GB recommended) 2 GB of available hard-disk space for installation;

additional free space required during installation (cannot install on removable flash storage

devices) 1024x768 display (1280x800 recommended) with 16-bit colour and 512 MB of

VRAM (1 GB recommended).

5.2.3.1. Hardware Requirements

**Machine A**

**Machine B**

Apple M1 (ARM)

AMD Ryzen 5 (3500H)

8GB DDR4

**CPU**

**RAM**

16GB LPDDR4

1TB Western Digital HDD

NVidia GTX 1650 4GB

**Storage**

**Graphics**

512GB Samsung UFS 3.0

Apple Afterburner 4GB

5.2.3.1. Software Requirements

**Machine A**

**Machine B**

Windows 11 (10.0.22)

**OS**

macOS Monterey (12.0.1)

Visual Studio Code: 1.62 **Text Editor** Visual Studio Code: 1.61.2

16.13.0

17.0.2

**Node**

**React**

17.1.0

17.0.2

8.0

**MySQL**

**Browser**

8.0.26

Chrome 96.0464

Chrome 96.0464

14





\6. Results and Discussions

6.1. Code Review

Let us discuss the basic workings of the AES system that we implemented. This is an

oversimplification of the actual steps we took to encrypt our data. For more details, we

encourage everyone to check out our GitHub Repository.

*Figure 8: Code Snippet To Generate Keys and IV. (JavaScript)*

*Figure 9: Validating Shared Keys and Encrypting the Data. (JavaScript)*

15





*Figure 10: Decrypting and Validating Authentication Tag. (JavaScript)*

*Figure 11: Encryption-Decryption Output.*

16





6.2. Screenshots of the Product

*Figure 12: Sign-In Portal*

*Figure 13: Account Registration Page*

*Figure 14: The Landing Page*

17





*Figure 15: User Information Update Page*

*Figure 16: Transaction Success Page*

*Figure 17: When Transfer Amount Exceeds Limit*

*Figure 18: When Transfer Amount Is Invalid*

18





*Figure 19: When Session Times Out*

*Figure 20: When Wrong Credentials Are Given*

6.3. Ending Remarks and Conclusions

6.3.1. Research & Development Conclusions

Our research and real-life testing have discovered that unless we upgrade our security

standards, it will only be a matter of time when they are overwhelmed and get cracked. Our

implementation with ReactJS, NodeJS and MySQL leave a lot to be desired.

A Biclique Analysis of the 256-bit AES shows promising results, which gives us a sense of

security of our future internet encryption standards. Like all other encryption standards, it will

break eventually, but this is better than facing completely preventable attacks right now.

6.3.2. Industry Discussions

At the RSA convention 2010 in California, the cryptographer panel consisting of legends such

as Ron Rivest of MIT, Adi Shamir, and former NSA director Brian Snow cited that one of the

highlights from 2009 was that AES-128 got broken. It took many people by surprise that this

mode could be broken, and the next logical question would be whether it is no longer suitable

for data protection?

19





However, this tidy realm of cryptography may be seriously agitated by the advent of quantum

computers.

***"There has been enormous growth in quantum computer technology in the past few years"***

says Michele Mosca, the Institute for Quantum Computing's Deputy Director at the University

of Waterloo. He notes that in the past 10+ years, we have moved from fiddling with quantum

bits to developing quantum logic gates. At that rate, he thinks it is likely we will have a quantum

computer within 15 years.

***"It is a game-changer"*** Mosca says, explaining that the difference comes not from

developments in the computer's clock speed but from an enormous reduction in the number of

moves needed to perform specific calculations.

Mosca explains that a quantum computer should be able to use the traits of quantum mechanics

to probe for patterns within a vast number without having to analyse every digit in that number.

Cracking both RSA and EC ciphers involves that same task -- finding patterns in huge numbers.

Therefore, keeping our data security in mind, we must migrate to a better encryption standard,

AES-256 currently, until we can feasibly use a different method.

[This Space Has Been Intentionally Kept Blank. Kindly Omit.]

20





\7. References

Weblinks:

\1. <https://bit.ly/3FUKWfA>[ ](https://bit.ly/3FUKWfA)(Accessed on September 23rd, 2021).

\2. <https://bit.ly/3lgExDu>[ ](https://bit.ly/3lgExDu)(Accessed on September 23rd, 2021).

\3. <https://bit.ly/31c2JQl>[ ](https://bit.ly/31c2JQl)(Accessed on October 13th, 2021).

\4. <https://bit.ly/3lhW0vk>[ ](https://bit.ly/3lhW0vk)(Accessed on October 15th, 2021).

\5. <https://bit.ly/3I5NhX0>[ ](https://bit.ly/3I5NhX0)(Accessed on October 15th, 2021).

\6. <https://bit.ly/32wSwyo>[ ](https://bit.ly/32wSwyo)(Accessed on November 8th, 2021).

Journal:

\1. Bogdanov A., Khovratovich D., Rechberger C. (2011) Biclique Cryptanalysis of the

Full AES. In: Lee D.H., Wang X. (eds) Advances in Cryptology – ASIACRYPT

\2011. Lecture Notes in Computer Science, vol 7073.

\2. Canteaut A., Fuhr T., Gilbert H., Naya-Plasencia M., Reinhard JR. (2015) Multiple

Differential Cryptanalysis of Round-Reduced PRINCE. In: Cid C., Rechberger C.

(eds) Fast Software Encryption. FSE 2014. Lecture Notes in Computer Science, vol

\8540.

\3. Canteaut A., Naya-Plasencia M., Vayssière B. (2013) Sieve-in-the-Middle:

Improved MITM Attacks. In: Canetti R., Garay J.A. (eds) Advances in Cryptology –

CRYPTO 2013. Lecture Notes in Computer Science, vol 8042.

\4. Abed F., Forler C., List E., Lucks S., Wenzel J. (2014) A Framework for Automated

Independent-Biclique Cryptanalysis. In: Moriai S. (eds) Fast Software Encryption.

FSE 2013. Lecture Notes in Computer Science, vol 8424.

\5. Tao, Biaoshuai and Hongjun Wu (2015). “Improving the Biclique Cryptanalysis of

AES.” ACISP.

Books:

\1. Daemen, J (2003). The Rijndael Block Cipher - NIST Computer Security.

\2. Abdullah, Ako. (2017). Advanced Encryption Standard (AES) Algorithm to Encrypt

and Decrypt Data.

21


